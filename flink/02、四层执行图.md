#1、介绍
StreamGraph：在Client生成  
JobGraph：在Client生成  
ExecutionGraph：在JobManager生成  
物理执行图：JobManager 根据 ExecutionGraph 对 Job 进行调度后，在各个TaskManager 上部署 Task 后形成的“图”，并不是一个具体的数据结构。

#2、主要流程

#3、核心类
##StreamExecutionEnvironment
flink程序入口。  
`List<Transformation<?>> transformations //datastream.map()等算子操作会往transformations 添加transformation`




开发者视角操作的是DataStream。  
datastream与transformation的关系？  
transformation与operator的关系？   
通过 DataStream –> StreamTransformation –> StreamOperator 这样的依赖关系，就可以完成 DataStream 的转换，并且保留数据流和应用在流上的算子之间的关系。
  OneInputStreamOperator、TwoInputStreamOperator区别？

slotsharinggroup：slot共享组，默认就是都在default组，即多个task可以共享一个slot，此时slot总数只需要满足job里最大并行度的个数，不需要计算不同算子加起来总共有多少并行task。
![](https://github.com/sunnyzhu92/notebook/blob/master/flink/img/01.slotsharinggroup.png)  
StreamTask：任务部署执行的最小单元。一个task包含1或多个算子（operatorchain，多个subtask chain成一个task）。  
TaskSlot：资源槽。job默认都在同一个slotsharinggroup里，那么多个task可以共享同一个slot，但是同一个operator的不同并发必须在不同的slot里。

一个slot里可运行多个task（task共享slot），每个task运行在一个线程里，task采用mailbox线程模型。
task怎么受slot资源槽的控制？？
#4、参考
